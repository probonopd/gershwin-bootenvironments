#import <Foundation/Foundation.h>
#import "MBMessage.h"

void hexdump_message(NSData *data, NSString *label) {
    const uint8_t *bytes = [data bytes];
    NSUInteger length = [data length];
    
    printf("\n=== %s (%lu bytes) ===\n", [label UTF8String], length);
    
    for (NSUInteger i = 0; i < length; i++) {
        if (i % 16 == 0) {
            printf("%04lx: ", i);
        }
        printf("%02x ", bytes[i]);
        if ((i + 1) % 16 == 0) {
            printf("\n");
        }
    }
    if (length % 16 != 0) {
        printf("\n");
    }
    
    // Parse header if possible
    if (length >= 16) {
        uint8_t endian = bytes[0];
        uint8_t type = bytes[1];
        uint8_t flags = bytes[2];
        uint8_t version = bytes[3];
        uint32_t body_len = *(uint32_t*)(bytes + 4);
        uint32_t serial = *(uint32_t*)(bytes + 8);
        uint32_t fields_len = *(uint32_t*)(bytes + 12);
        
        if (endian == 'l') {
            body_len = NSSwapLittleIntToHost(body_len);
            serial = NSSwapLittleIntToHost(serial);
            fields_len = NSSwapLittleIntToHost(fields_len);
        } else if (endian == 'B') {
            body_len = NSSwapBigIntToHost(body_len);
            serial = NSSwapBigIntToHost(serial);
            fields_len = NSSwapBigIntToHost(fields_len);
        }
        
        printf("Header: endian=%c type=%u flags=%u version=%u\n", endian, type, flags, version);
        printf("        body_len=%u serial=%u fields_len=%u\n", body_len, serial, fields_len);
        
        // Show field area
        if (16 + fields_len <= length) {
            printf("Header fields (%u bytes):\n", fields_len);
            for (NSUInteger i = 16; i < 16 + fields_len && i < length; i++) {
                if ((i - 16) % 16 == 0) {
                    printf("  %04lx: ", i - 16);
                }
                printf("%02x ", bytes[i]);
                if ((i - 16 + 1) % 16 == 0) {
                    printf("\n");
                }
            }
            if (fields_len % 16 != 0) {
                printf("\n");
            }
            
            // Calculate body start and show body
            NSUInteger body_start = 16 + fields_len;
            body_start = (body_start + 7) & ~7; // Align to 8 bytes
            
            if (body_start < length) {
                printf("Message body (starts at offset %lu):\n", body_start);
                for (NSUInteger i = body_start; i < length && i < body_start + body_len; i++) {
                    if ((i - body_start) % 16 == 0) {
                        printf("  %04lx: ", i - body_start);
                    }
                    printf("%02x ", bytes[i]);
                    if ((i - body_start + 1) % 16 == 0) {
                        printf("\n");
                    }
                }
                if ((length - body_start) % 16 != 0) {
                    printf("\n");
                }
            }
        }
    }
    printf("=== End %s ===\n\n", [label UTF8String]);
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // Actual problematic data from MiniBus logs (884-byte buffer)
        uint8_t problem_buffer[] = {
            0x6c, 0x01, 0x00, 0x01, 0x14, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x7d, 0x00, 0x00, 0x00,  // Message 1 header
            0x01, 0x01, 0x6f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x2f, 0x6f, 0x72, 0x67, 0x2f, 0x66, 0x72, 0x65,  // Message 1 fields
            0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2f, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00,
            0x02, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65,
            0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00,
            0x06, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72, 0x65, 0x65,
            0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00,
            0x08, 0x01, 0x67, 0x00, 0x01, 0x73, 0x00, 0x00, 0x03, 0x01, 0x73, 0x00, 0x0c, 0x00, 0x00, 0x00,
            0x47, 0x65, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00,
            0x0f, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e, 0x78, 0x66, 0x63, 0x65, 0x2e, 0x58, 0x66, 0x63,  // Message 1 body starts around here
            0x6f, 0x6e, 0x66, 0x00, // Message 1 ends at 0xa3, Message 2 starts at 0xa4
            0x6c, 0x01, 0x00, 0x01, 0xa1, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,  // Message 2 header
            0x79, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6f, 0x00, 0x15, 0x00, 0x00, 0x00, 0x2f, 0x6f, 0x72, 0x67,  // Message 2 fields
            0x2f, 0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2f, 0x44, 0x42, 0x75,
            0x73, 0x00, 0x00, 0x00, 0x02, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e,
            0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73,
            0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x73, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6f, 0x72, 0x67, 0x2e,
            0x66, 0x72, 0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x67, 0x00, 0x01, 0x73, 0x00, 0x00, 0x03, 0x01, 0x73, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x41, 0x64, 0x64, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x00, 0x00, 0x00, 0x00,
            // Message 2 body (AddMatch string)
            0x00, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x74, 0x79, 0x70, 0x65, 0x3d, 0x27, 0x73, 0x69,
            0x67, 0x6e, 0x61, 0x6c, 0x27, 0x2c, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x3d, 0x27, 0x6f, 0x72,
            0x67, 0x2e, 0x78, 0x66, 0x63, 0x65, 0x2e, 0x58, 0x66, 0x63, 0x6f, 0x6e, 0x66, 0x27, 0x2c, 0x69,
            0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x3d, 0x27, 0x6f, 0x72, 0x67, 0x2e, 0x66, 0x72,
            0x65, 0x65, 0x64, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70, 0x2e, 0x44, 0x42, 0x75, 0x73, 0x2e, 0x50,
            0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x27, 0x2c, 0x6d, 0x65, 0x6d, 0x62, 0x65,
            0x72, 0x3d, 0x27, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x43, 0x68, 0x61,
            0x6e, 0x67, 0x65, 0x64, 0x27, 0x2c, 0x70, 0x61, 0x74, 0x68, 0x3d, 0x27, 0x2f, 0x6f, 0x72, 0x67,
            0x2f, 0x78, 0x66, 0x63, 0x65, 0x2f, 0x58, 0x66, 0x63, 0x6f, 0x6e, 0x66, 0x27, 0x2c, 0x61, 0x72,
            0x67, 0x30, 0x3d, 0x27, 0x6f, 0x72, 0x67, 0x2e, 0x78, 0x66, 0x63, 0x65, 0x2e, 0x58, 0x66, 0x63,
            // Continue with more data...
        };
        
        NSData *problemData = [NSData dataWithBytes:problem_buffer length:sizeof(problem_buffer)];
        hexdump_message(problemData, @"Problematic Multi-Message Buffer");
        
        // Try to parse individual messages
        printf("\n=== TESTING MESSAGE PARSING ===\n");
        NSUInteger offset = 0;
        int messageCount = 0;
        
        while (offset < [problemData length] && messageCount < 5) {
            NSUInteger oldOffset = offset;
            MBMessage *message = [MBMessage messageFromData:problemData offset:&offset];
            
            if (message) {
                messageCount++;
                printf("Message %d: parsed successfully, consumed %lu bytes (offset %lu -> %lu)\n", 
                       messageCount, offset - oldOffset, oldOffset, offset);
                printf("  Type: %d, Serial: %lu, Member: %s\n", 
                       (int)message.type, message.serial, 
                       message.member ? [message.member UTF8String] : "null");
            } else {
                printf("Message %d: failed to parse at offset %lu\n", messageCount + 1, offset);
                break;
            }
        }
        
        printf("=== PARSING TEST COMPLETE ===\n");
    }
    return 0;
}
